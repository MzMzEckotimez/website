---
title:    problem. solution
tagline:  "and here's where I keep assorted lengths of wire" - HJF
---

Luapower is a custom selection of Lua and C libraries chosen for speed,
portability, API stability and a free license. On top of that, a growing
collection of ffi bindings and Lua modules, all packaged to minimize the
friction in putting together LuaJIT environment for general-purpose
programming.

On this page I will try to make the case for luapower based on its main
characteristics.

## LOW-TECH

Being easy to use is one of the main goals of luapower. This means leveraging
technologies that we already know and use instead of creating new ones.
It means providing the lowest-tech method of acheiving any task, and
providing a more powerful way only as an alternative.

  * the entire luapower consumption workflow is based on http, zip,
  and/or git, and optionally, a simple git wrapper script for cloning in the
  whole kitchen sink at once.

  * the module production workflow is based on just naming conventions
  and git, enhanced by the same git wrapper for making it easy to work
  with multiple repositories.

  * the package database is generated by a single Lua script.

  * luapower.com is a simple website written entirely in Lua.

## PORTABLE

The work tree can be moved around from system to system, and even between
different platforms, and just work.

This means including the binary dependencies that the code was actually
tested against, instead of relying on the OS ones, and making sure that Lua
loads the local ones over the system ones.

It also means putting together all binaries for all platforms in the same
tree (no branches). If space is really a problem (android) then deleting
other platform directories just before packaging the app is easier than
checking out per-platform "binary" branches for each module and thus
requiring multiple work trees.

Finally the work tree also works as deployment tree, thus there's no
deployment step, unless you have special needs.

## MODULAR

Each Lua module has its own life and death, its own repository, commit
history, version history (git tags), issues and forks and pull requests.

This allows luapower to evolve gradually and incrementally, allowing old and
obsolete modules to stick around for as long as there are users for them,
and yet their presence not bother everyone else.

Additionally, luapower modules from different people can be put together to
build an entire app by just copying directories over each other, or by
cloning git repositories.

## GIT & GITHUB

To me the biggest barrier to getting involved in projects online is the
friction that our collaboration tools inflict on us. This goes for anything
from correcting a typo on wikipedia to submitting a patch to the Linux kernel.
Github is just one way to lower that barrier in the realm of programming.

As for git, the reason for having everything under git's control all the time
is basically Alan Kay's idea of symmetric authoring and consumption, which
says that you have to be able to edit and share back what you consume on the
spot. The combination of a code editor and a VCS is the closest we have today
to that idea as far as coding goes. It's not much, but it's definitely better
than most package managers which copy modules out of the git tree.

## NO DIRECTORIES

This is a hard sell, I know, but I stand by it. Directories are evil. Not so
much because of semantics (hierarchical classification systems are evil),
but because of the tools we use (file browsers, code editors, IDEs, command
line) suck at working with them. You don't have instant search in most of them
(sublime text excepted), but you have to "navigate" them instead (this is
true for GUIs and it's true for the command line as well). Also, one of the
major reasons for directory hierarchies is structuring information for humans
to consume in the learning phase. In the case of a module distribution, the
structure of a package is the same for all packages. Thus the juxtaposition
of files from many modules doesn't make things less organized. If you feel
uneasy about a long flat list of files, try organizing them into directories,
learn the structure of the information, then put them back. You will see
that directories are no longer useful after this stage.

Philosophy aside, having all the modules in the same directory is the way
`require()` works by default, which means there's no need to add a custom
`require` loader to find modules.

The downside is that we have to wrap git to work with overlaid repositories.

## BINARIES

I should not be forced to compile stuff. Not even in Linux. You should let me
play around with the library before I even decide if I want to incorporate it
in my project or not.

## C SOURCES & BUILD SCRIPTS

I know I'm going against the grain with this one, but I deeply hate C build
systems and I think for the most part that they are unnecessary. For me, the
success rate for going from `make` to `dll` on the first shot has always been
pretty pathetic. Building with one-liner gcc scripts is much more transparent,
which directly affects my ability and motivation to fix problems (which in
turn affects the number of packages built). It compiles much faster too.

To me it boils down to how much indirection there is between problem (in this
case the .c and .h files) and solution (the gcc compiler). Sure, you have to
remember a few gcc switches, but they are _the same_ switches for any library
that you will ever build.

This also allows me to apply a set of decisions consistently across the
entire distribution, like, if libgcc should be statically built or not.

## PACKAGE DATABASE

Package type, version, supported platforms, license, etc., this is information
that needs to be aggregated and presented in a way that can be sorted and
filtered. Almost no website shows that.

## DOCUMENTATION

Make it as easy as possible to produce, and as comfortable as possible to
consume. For production, this means plain-text with good support for tables
(invaluable for tech docs of any kind), and a markup format independent of
any wiki engine, web framework or hosting provider (incidentally, the
git-flavored markdown fails on both the independence aspect and table
support). I went with pandoc here because it has the best table support
I've seen, and you can even write custom writers in Lua (and filters in any
language that can read and write json). It also supports a variety of markup
formats for input, which could come in handy for aggregating 3rd party docs
into the website. Which brings me to the consumption part: docs should start
with a quick-ref table listing the entire API. Chances are you'll rarely look
beyound that table once you get past the initial learning curve for that API.

## FREEDOM

My code is in [public domain (PD)](http://unlicense.org/) as I
[do not support][against ip] the copyright law. The rest is mostly free as-in
non-viral, to avoid the case where one module is imposing licensing
restrictions on _other_ modules and on your own applications.


[against ip]:  http://www.stephankinsella.com/publications/#againstip
